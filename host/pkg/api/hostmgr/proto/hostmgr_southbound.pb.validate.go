// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: hostmgr/proto/hostmgr_southbound.proto

package hostmgr_southbound

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _hostmgr_southbound_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on HostStatus with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HostStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HostStatusMultiError, or
// nil if none found.
func (m *HostStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *HostStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostStatus

	// no validation rules for Details

	// no validation rules for HumanReadableStatus

	if len(errors) > 0 {
		return HostStatusMultiError(errors)
	}

	return nil
}

// HostStatusMultiError is an error wrapping multiple validation errors
// returned by HostStatus.ValidateAll() if the designated constraints aren't met.
type HostStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostStatusMultiError) AllErrors() []error { return m }

// HostStatusValidationError is the validation error returned by
// HostStatus.Validate if the designated constraints aren't met.
type HostStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostStatusValidationError) ErrorName() string { return "HostStatusValidationError" }

// Error satisfies the builtin error interface
func (e HostStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostStatusValidationError{}

// Validate checks the field values on HostStatusResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HostStatusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostStatusResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HostStatusRespMultiError,
// or nil if none found.
func (m *HostStatusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *HostStatusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostAction

	// no validation rules for Details

	if len(errors) > 0 {
		return HostStatusRespMultiError(errors)
	}

	return nil
}

// HostStatusRespMultiError is an error wrapping multiple validation errors
// returned by HostStatusResp.ValidateAll() if the designated constraints
// aren't met.
type HostStatusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostStatusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostStatusRespMultiError) AllErrors() []error { return m }

// HostStatusRespValidationError is the validation error returned by
// HostStatusResp.Validate if the designated constraints aren't met.
type HostStatusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostStatusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostStatusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostStatusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostStatusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostStatusRespValidationError) ErrorName() string { return "HostStatusRespValidationError" }

// Error satisfies the builtin error interface
func (e HostStatusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostStatusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostStatusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostStatusRespValidationError{}

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataMultiError, or nil
// if none found.
func (m *Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return MetadataMultiError(errors)
	}

	return nil
}

// MetadataMultiError is an error wrapping multiple validation errors returned
// by Metadata.ValidateAll() if the designated constraints aren't met.
type MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataMultiError) AllErrors() []error { return m }

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on SystemInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemInfoMultiError, or
// nil if none found.
func (m *SystemInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHwInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SystemInfoValidationError{
					field:  "HwInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SystemInfoValidationError{
					field:  "HwInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHwInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SystemInfoValidationError{
				field:  "HwInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOsInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SystemInfoValidationError{
					field:  "OsInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SystemInfoValidationError{
					field:  "OsInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOsInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SystemInfoValidationError{
				field:  "OsInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBmCtlInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SystemInfoValidationError{
					field:  "BmCtlInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SystemInfoValidationError{
					field:  "BmCtlInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBmCtlInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SystemInfoValidationError{
				field:  "BmCtlInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBiosInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SystemInfoValidationError{
					field:  "BiosInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SystemInfoValidationError{
					field:  "BiosInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBiosInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SystemInfoValidationError{
				field:  "BiosInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SystemInfoMultiError(errors)
	}

	return nil
}

// SystemInfoMultiError is an error wrapping multiple validation errors
// returned by SystemInfo.ValidateAll() if the designated constraints aren't met.
type SystemInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemInfoMultiError) AllErrors() []error { return m }

// SystemInfoValidationError is the validation error returned by
// SystemInfo.Validate if the designated constraints aren't met.
type SystemInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemInfoValidationError) ErrorName() string { return "SystemInfoValidationError" }

// Error satisfies the builtin error interface
func (e SystemInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemInfoValidationError{}

// Validate checks the field values on BiosInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BiosInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BiosInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BiosInfoMultiError, or nil
// if none found.
func (m *BiosInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BiosInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetVersion() != "" {

		if utf8.RuneCountInString(m.GetVersion()) > 128 {
			err := BiosInfoValidationError{
				field:  "Version",
				reason: "value length must be at most 128 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetReleaseDate() != "" {

		if utf8.RuneCountInString(m.GetReleaseDate()) > 128 {
			err := BiosInfoValidationError{
				field:  "ReleaseDate",
				reason: "value length must be at most 128 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_BiosInfo_ReleaseDate_Pattern.MatchString(m.GetReleaseDate()) {
			err := BiosInfoValidationError{
				field:  "ReleaseDate",
				reason: "value does not match regex pattern \"^(0[1-9]|1[012])[/](0[1-9]|[12][0-9]|3[01])[/](19|20)\\\\d\\\\d$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetVendor() != "" {

		if utf8.RuneCountInString(m.GetVendor()) > 40 {
			err := BiosInfoValidationError{
				field:  "Vendor",
				reason: "value length must be at most 40 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return BiosInfoMultiError(errors)
	}

	return nil
}

// BiosInfoMultiError is an error wrapping multiple validation errors returned
// by BiosInfo.ValidateAll() if the designated constraints aren't met.
type BiosInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BiosInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BiosInfoMultiError) AllErrors() []error { return m }

// BiosInfoValidationError is the validation error returned by
// BiosInfo.Validate if the designated constraints aren't met.
type BiosInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BiosInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BiosInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BiosInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BiosInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BiosInfoValidationError) ErrorName() string { return "BiosInfoValidationError" }

// Error satisfies the builtin error interface
func (e BiosInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBiosInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BiosInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BiosInfoValidationError{}

var _BiosInfo_ReleaseDate_Pattern = regexp.MustCompile("^(0[1-9]|1[012])[/](0[1-9]|[12][0-9]|3[01])[/](19|20)\\d\\d$")

// Validate checks the field values on OsInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OsInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OsInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OsInfoMultiError, or nil if none found.
func (m *OsInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *OsInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetKernel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OsInfoValidationError{
					field:  "Kernel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OsInfoValidationError{
					field:  "Kernel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKernel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OsInfoValidationError{
				field:  "Kernel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRelease()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OsInfoValidationError{
					field:  "Release",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OsInfoValidationError{
					field:  "Release",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRelease()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OsInfoValidationError{
				field:  "Release",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OsInfoMultiError(errors)
	}

	return nil
}

// OsInfoMultiError is an error wrapping multiple validation errors returned by
// OsInfo.ValidateAll() if the designated constraints aren't met.
type OsInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OsInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OsInfoMultiError) AllErrors() []error { return m }

// OsInfoValidationError is the validation error returned by OsInfo.Validate if
// the designated constraints aren't met.
type OsInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OsInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OsInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OsInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OsInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OsInfoValidationError) ErrorName() string { return "OsInfoValidationError" }

// Error satisfies the builtin error interface
func (e OsInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOsInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OsInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OsInfoValidationError{}

// Validate checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Config) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ConfigMultiError, or nil if none found.
func (m *Config) ValidateAll() error {
	return m.validate(true)
}

func (m *Config) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return ConfigMultiError(errors)
	}

	return nil
}

// ConfigMultiError is an error wrapping multiple validation errors returned by
// Config.ValidateAll() if the designated constraints aren't met.
type ConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMultiError) AllErrors() []error { return m }

// ConfigValidationError is the validation error returned by Config.Validate if
// the designated constraints aren't met.
type ConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigValidationError) ErrorName() string { return "ConfigValidationError" }

// Error satisfies the builtin error interface
func (e ConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigValidationError{}

// Validate checks the field values on OsKernel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OsKernel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OsKernel with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OsKernelMultiError, or nil
// if none found.
func (m *OsKernel) ValidateAll() error {
	return m.validate(true)
}

func (m *OsKernel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetVersion()) > 128 {
		err := OsKernelValidationError{
			field:  "Version",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetConfig() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OsKernelValidationError{
						field:  fmt.Sprintf("Config[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OsKernelValidationError{
						field:  fmt.Sprintf("Config[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OsKernelValidationError{
					field:  fmt.Sprintf("Config[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OsKernelMultiError(errors)
	}

	return nil
}

// OsKernelMultiError is an error wrapping multiple validation errors returned
// by OsKernel.ValidateAll() if the designated constraints aren't met.
type OsKernelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OsKernelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OsKernelMultiError) AllErrors() []error { return m }

// OsKernelValidationError is the validation error returned by
// OsKernel.Validate if the designated constraints aren't met.
type OsKernelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OsKernelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OsKernelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OsKernelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OsKernelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OsKernelValidationError) ErrorName() string { return "OsKernelValidationError" }

// Error satisfies the builtin error interface
func (e OsKernelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOsKernel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OsKernelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OsKernelValidationError{}

// Validate checks the field values on OsRelease with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OsRelease) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OsRelease with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OsReleaseMultiError, or nil
// if none found.
func (m *OsRelease) ValidateAll() error {
	return m.validate(true)
}

func (m *OsRelease) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) > 128 {
		err := OsReleaseValidationError{
			field:  "Id",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVersion()) > 128 {
		err := OsReleaseValidationError{
			field:  "Version",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMetadata() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OsReleaseValidationError{
						field:  fmt.Sprintf("Metadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OsReleaseValidationError{
						field:  fmt.Sprintf("Metadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OsReleaseValidationError{
					field:  fmt.Sprintf("Metadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OsReleaseMultiError(errors)
	}

	return nil
}

// OsReleaseMultiError is an error wrapping multiple validation errors returned
// by OsRelease.ValidateAll() if the designated constraints aren't met.
type OsReleaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OsReleaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OsReleaseMultiError) AllErrors() []error { return m }

// OsReleaseValidationError is the validation error returned by
// OsRelease.Validate if the designated constraints aren't met.
type OsReleaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OsReleaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OsReleaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OsReleaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OsReleaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OsReleaseValidationError) ErrorName() string { return "OsReleaseValidationError" }

// Error satisfies the builtin error interface
func (e OsReleaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOsRelease.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OsReleaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OsReleaseValidationError{}

// Validate checks the field values on Storage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Storage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Storage with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StorageMultiError, or nil if none found.
func (m *Storage) ValidateAll() error {
	return m.validate(true)
}

func (m *Storage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDisk() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  fmt.Sprintf("Disk[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  fmt.Sprintf("Disk[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageValidationError{
					field:  fmt.Sprintf("Disk[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StorageMultiError(errors)
	}

	return nil
}

// StorageMultiError is an error wrapping multiple validation errors returned
// by Storage.ValidateAll() if the designated constraints aren't met.
type StorageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageMultiError) AllErrors() []error { return m }

// StorageValidationError is the validation error returned by Storage.Validate
// if the designated constraints aren't met.
type StorageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageValidationError) ErrorName() string { return "StorageValidationError" }

// Error satisfies the builtin error interface
func (e StorageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageValidationError{}

// Validate checks the field values on HWInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HWInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HWInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HWInfoMultiError, or nil if none found.
func (m *HWInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *HWInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSerialNum()) > 128 {
		err := HWInfoValidationError{
			field:  "SerialNum",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProductName()) > 128 {
		err := HWInfoValidationError{
			field:  "ProductName",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCpu()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HWInfoValidationError{
					field:  "Cpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HWInfoValidationError{
					field:  "Cpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCpu()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HWInfoValidationError{
				field:  "Cpu",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGpuDeprecated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HWInfoValidationError{
					field:  "GpuDeprecated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HWInfoValidationError{
					field:  "GpuDeprecated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGpuDeprecated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HWInfoValidationError{
				field:  "GpuDeprecated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMemory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HWInfoValidationError{
					field:  "Memory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HWInfoValidationError{
					field:  "Memory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMemory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HWInfoValidationError{
				field:  "Memory",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStorage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HWInfoValidationError{
					field:  "Storage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HWInfoValidationError{
					field:  "Storage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStorage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HWInfoValidationError{
				field:  "Storage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNetwork() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HWInfoValidationError{
						field:  fmt.Sprintf("Network[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HWInfoValidationError{
						field:  fmt.Sprintf("Network[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HWInfoValidationError{
					field:  fmt.Sprintf("Network[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPci() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HWInfoValidationError{
						field:  fmt.Sprintf("Pci[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HWInfoValidationError{
						field:  fmt.Sprintf("Pci[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HWInfoValidationError{
					field:  fmt.Sprintf("Pci[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetUsb() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HWInfoValidationError{
						field:  fmt.Sprintf("Usb[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HWInfoValidationError{
						field:  fmt.Sprintf("Usb[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HWInfoValidationError{
					field:  fmt.Sprintf("Usb[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetGpu() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HWInfoValidationError{
						field:  fmt.Sprintf("Gpu[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HWInfoValidationError{
						field:  fmt.Sprintf("Gpu[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HWInfoValidationError{
					field:  fmt.Sprintf("Gpu[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HWInfoMultiError(errors)
	}

	return nil
}

// HWInfoMultiError is an error wrapping multiple validation errors returned by
// HWInfo.ValidateAll() if the designated constraints aren't met.
type HWInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HWInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HWInfoMultiError) AllErrors() []error { return m }

// HWInfoValidationError is the validation error returned by HWInfo.Validate if
// the designated constraints aren't met.
type HWInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HWInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HWInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HWInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HWInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HWInfoValidationError) ErrorName() string { return "HWInfoValidationError" }

// Error satisfies the builtin error interface
func (e HWInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHWInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HWInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HWInfoValidationError{}

// Validate checks the field values on SystemCPU with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemCPU) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemCPU with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemCPUMultiError, or nil
// if none found.
func (m *SystemCPU) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemCPU) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetArch()) > 128 {
		err := SystemCPUValidationError{
			field:  "Arch",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVendor()) > 128 {
		err := SystemCPUValidationError{
			field:  "Vendor",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetModel()) > 128 {
		err := SystemCPUValidationError{
			field:  "Model",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSockets() <= 0 {
		err := SystemCPUValidationError{
			field:  "Sockets",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetCores() <= 0 {
		err := SystemCPUValidationError{
			field:  "Cores",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetThreads() <= 0 {
		err := SystemCPUValidationError{
			field:  "Threads",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCpuTopology()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SystemCPUValidationError{
					field:  "CpuTopology",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SystemCPUValidationError{
					field:  "CpuTopology",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCpuTopology()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SystemCPUValidationError{
				field:  "CpuTopology",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SystemCPUMultiError(errors)
	}

	return nil
}

// SystemCPUMultiError is an error wrapping multiple validation errors returned
// by SystemCPU.ValidateAll() if the designated constraints aren't met.
type SystemCPUMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemCPUMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemCPUMultiError) AllErrors() []error { return m }

// SystemCPUValidationError is the validation error returned by
// SystemCPU.Validate if the designated constraints aren't met.
type SystemCPUValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemCPUValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemCPUValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemCPUValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemCPUValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemCPUValidationError) ErrorName() string { return "SystemCPUValidationError" }

// Error satisfies the builtin error interface
func (e SystemCPUValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemCPU.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemCPUValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemCPUValidationError{}

// Validate checks the field values on SystemMemory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemMemory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemMemory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemMemoryMultiError, or
// nil if none found.
func (m *SystemMemory) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemMemory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSize() <= 0 {
		err := SystemMemoryValidationError{
			field:  "Size",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SystemMemoryMultiError(errors)
	}

	return nil
}

// SystemMemoryMultiError is an error wrapping multiple validation errors
// returned by SystemMemory.ValidateAll() if the designated constraints aren't met.
type SystemMemoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemMemoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemMemoryMultiError) AllErrors() []error { return m }

// SystemMemoryValidationError is the validation error returned by
// SystemMemory.Validate if the designated constraints aren't met.
type SystemMemoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemMemoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemMemoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemMemoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemMemoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemMemoryValidationError) ErrorName() string { return "SystemMemoryValidationError" }

// Error satisfies the builtin error interface
func (e SystemMemoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemMemory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemMemoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemMemoryValidationError{}

// Validate checks the field values on SystemDisk with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemDisk) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemDisk with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemDiskMultiError, or
// nil if none found.
func (m *SystemDisk) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemDisk) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSerialNumber()) > 128 {
		err := SystemDiskValidationError{
			field:  "SerialNumber",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 128 {
		err := SystemDiskValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVendor()) > 128 {
		err := SystemDiskValidationError{
			field:  "Vendor",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetModel()) > 128 {
		err := SystemDiskValidationError{
			field:  "Model",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Size

	if utf8.RuneCountInString(m.GetWwid()) > 128 {
		err := SystemDiskValidationError{
			field:  "Wwid",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SystemDiskMultiError(errors)
	}

	return nil
}

// SystemDiskMultiError is an error wrapping multiple validation errors
// returned by SystemDisk.ValidateAll() if the designated constraints aren't met.
type SystemDiskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemDiskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemDiskMultiError) AllErrors() []error { return m }

// SystemDiskValidationError is the validation error returned by
// SystemDisk.Validate if the designated constraints aren't met.
type SystemDiskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemDiskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemDiskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemDiskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemDiskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemDiskValidationError) ErrorName() string { return "SystemDiskValidationError" }

// Error satisfies the builtin error interface
func (e SystemDiskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemDisk.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemDiskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemDiskValidationError{}

// Validate checks the field values on SystemGPU with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemGPU) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemGPU with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemGPUMultiError, or nil
// if none found.
func (m *SystemGPU) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemGPU) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPciId() != "" {

		if l := utf8.RuneCountInString(m.GetPciId()); l < 1 || l > 128 {
			err := SystemGPUValidationError{
				field:  "PciId",
				reason: "value length must be between 1 and 128 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if utf8.RuneCountInString(m.GetProduct()) > 128 {
		err := SystemGPUValidationError{
			field:  "Product",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetVendor()) > 128 {
		err := SystemGPUValidationError{
			field:  "Vendor",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetName() != "" {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 128 {
			err := SystemGPUValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 128 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if utf8.RuneCountInString(m.GetDescription()) > 128 {
		err := SystemGPUValidationError{
			field:  "Description",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SystemGPUMultiError(errors)
	}

	return nil
}

// SystemGPUMultiError is an error wrapping multiple validation errors returned
// by SystemGPU.ValidateAll() if the designated constraints aren't met.
type SystemGPUMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemGPUMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemGPUMultiError) AllErrors() []error { return m }

// SystemGPUValidationError is the validation error returned by
// SystemGPU.Validate if the designated constraints aren't met.
type SystemGPUValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemGPUValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemGPUValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemGPUValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemGPUValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemGPUValidationError) ErrorName() string { return "SystemGPUValidationError" }

// Error satisfies the builtin error interface
func (e SystemGPUValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemGPU.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemGPUValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemGPUValidationError{}

// Validate checks the field values on SystemNetwork with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemNetwork) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemNetwork with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemNetworkMultiError, or
// nil if none found.
func (m *SystemNetwork) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemNetwork) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 128 {
		err := SystemNetworkValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 128 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPciId()) > 128 {
		err := SystemNetworkValidationError{
			field:  "PciId",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetMac()) > 128 {
		err := SystemNetworkValidationError{
			field:  "Mac",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for LinkState

	// no validation rules for CurrentSpeed

	if utf8.RuneCountInString(m.GetCurrentDuplex()) > 128 {
		err := SystemNetworkValidationError{
			field:  "CurrentDuplex",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Sriovenabled

	// no validation rules for Sriovnumvfs

	// no validation rules for SriovVfsTotal

	if utf8.RuneCountInString(m.GetPeerName()) > 128 {
		err := SystemNetworkValidationError{
			field:  "PeerName",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeerDescription()) > 128 {
		err := SystemNetworkValidationError{
			field:  "PeerDescription",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeerMac()) > 128 {
		err := SystemNetworkValidationError{
			field:  "PeerMac",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeerMgmtIp()) > 128 {
		err := SystemNetworkValidationError{
			field:  "PeerMgmtIp",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeerPort()) > 128 {
		err := SystemNetworkValidationError{
			field:  "PeerPort",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetIpAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SystemNetworkValidationError{
						field:  fmt.Sprintf("IpAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SystemNetworkValidationError{
						field:  fmt.Sprintf("IpAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SystemNetworkValidationError{
					field:  fmt.Sprintf("IpAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Mtu

	// no validation rules for BmcNet

	if len(errors) > 0 {
		return SystemNetworkMultiError(errors)
	}

	return nil
}

// SystemNetworkMultiError is an error wrapping multiple validation errors
// returned by SystemNetwork.ValidateAll() if the designated constraints
// aren't met.
type SystemNetworkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemNetworkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemNetworkMultiError) AllErrors() []error { return m }

// SystemNetworkValidationError is the validation error returned by
// SystemNetwork.Validate if the designated constraints aren't met.
type SystemNetworkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemNetworkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemNetworkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemNetworkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemNetworkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemNetworkValidationError) ErrorName() string { return "SystemNetworkValidationError" }

// Error satisfies the builtin error interface
func (e SystemNetworkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemNetwork.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemNetworkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemNetworkValidationError{}

// Validate checks the field values on CPUTopology with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CPUTopology) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CPUTopology with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CPUTopologyMultiError, or
// nil if none found.
func (m *CPUTopology) ValidateAll() error {
	return m.validate(true)
}

func (m *CPUTopology) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSockets()) < 1 {
		err := CPUTopologyValidationError{
			field:  "Sockets",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSockets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CPUTopologyValidationError{
						field:  fmt.Sprintf("Sockets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CPUTopologyValidationError{
						field:  fmt.Sprintf("Sockets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CPUTopologyValidationError{
					field:  fmt.Sprintf("Sockets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CPUTopologyMultiError(errors)
	}

	return nil
}

// CPUTopologyMultiError is an error wrapping multiple validation errors
// returned by CPUTopology.ValidateAll() if the designated constraints aren't met.
type CPUTopologyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CPUTopologyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CPUTopologyMultiError) AllErrors() []error { return m }

// CPUTopologyValidationError is the validation error returned by
// CPUTopology.Validate if the designated constraints aren't met.
type CPUTopologyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CPUTopologyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CPUTopologyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CPUTopologyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CPUTopologyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CPUTopologyValidationError) ErrorName() string { return "CPUTopologyValidationError" }

// Error satisfies the builtin error interface
func (e CPUTopologyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCPUTopology.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CPUTopologyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CPUTopologyValidationError{}

// Validate checks the field values on Socket with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Socket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Socket with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SocketMultiError, or nil if none found.
func (m *Socket) ValidateAll() error {
	return m.validate(true)
}

func (m *Socket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SocketId

	if len(m.GetCoreGroups()) < 1 {
		err := SocketValidationError{
			field:  "CoreGroups",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetCoreGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SocketValidationError{
						field:  fmt.Sprintf("CoreGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SocketValidationError{
						field:  fmt.Sprintf("CoreGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SocketValidationError{
					field:  fmt.Sprintf("CoreGroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SocketMultiError(errors)
	}

	return nil
}

// SocketMultiError is an error wrapping multiple validation errors returned by
// Socket.ValidateAll() if the designated constraints aren't met.
type SocketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SocketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SocketMultiError) AllErrors() []error { return m }

// SocketValidationError is the validation error returned by Socket.Validate if
// the designated constraints aren't met.
type SocketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SocketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SocketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SocketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SocketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SocketValidationError) ErrorName() string { return "SocketValidationError" }

// Error satisfies the builtin error interface
func (e SocketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSocket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SocketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SocketValidationError{}

// Validate checks the field values on CoreGroup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CoreGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoreGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CoreGroupMultiError, or nil
// if none found.
func (m *CoreGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *CoreGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CoreType

	if len(m.GetCoreList()) < 1 {
		err := CoreGroupValidationError{
			field:  "CoreList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CoreGroup_CoreList_Unique := make(map[uint32]struct{}, len(m.GetCoreList()))

	for idx, item := range m.GetCoreList() {
		_, _ = idx, item

		if _, exists := _CoreGroup_CoreList_Unique[item]; exists {
			err := CoreGroupValidationError{
				field:  fmt.Sprintf("CoreList[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CoreGroup_CoreList_Unique[item] = struct{}{}
		}

		// no validation rules for CoreList[idx]
	}

	if len(errors) > 0 {
		return CoreGroupMultiError(errors)
	}

	return nil
}

// CoreGroupMultiError is an error wrapping multiple validation errors returned
// by CoreGroup.ValidateAll() if the designated constraints aren't met.
type CoreGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoreGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoreGroupMultiError) AllErrors() []error { return m }

// CoreGroupValidationError is the validation error returned by
// CoreGroup.Validate if the designated constraints aren't met.
type CoreGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoreGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoreGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoreGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoreGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoreGroupValidationError) ErrorName() string { return "CoreGroupValidationError" }

// Error satisfies the builtin error interface
func (e CoreGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoreGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoreGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoreGroupValidationError{}

// Validate checks the field values on IPAddress with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IPAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IPAddressMultiError, or nil
// if none found.
func (m *IPAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *IPAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetIpAddress()); ip == nil {
		err := IPAddressValidationError{
			field:  "IpAddress",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetNetworkPrefixBits(); val < 1 || val >= 128 {
		err := IPAddressValidationError{
			field:  "NetworkPrefixBits",
			reason: "value must be inside range [1, 128)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ConfigMode

	if len(errors) > 0 {
		return IPAddressMultiError(errors)
	}

	return nil
}

// IPAddressMultiError is an error wrapping multiple validation errors returned
// by IPAddress.ValidateAll() if the designated constraints aren't met.
type IPAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPAddressMultiError) AllErrors() []error { return m }

// IPAddressValidationError is the validation error returned by
// IPAddress.Validate if the designated constraints aren't met.
type IPAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPAddressValidationError) ErrorName() string { return "IPAddressValidationError" }

// Error satisfies the builtin error interface
func (e IPAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPAddressValidationError{}

// Validate checks the field values on SystemPCI with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemPCI) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemPCI with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemPCIMultiError, or nil
// if none found.
func (m *SystemPCI) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemPCI) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDevClass()) > 128 {
		err := SystemPCIValidationError{
			field:  "DevClass",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SystemPCIMultiError(errors)
	}

	return nil
}

// SystemPCIMultiError is an error wrapping multiple validation errors returned
// by SystemPCI.ValidateAll() if the designated constraints aren't met.
type SystemPCIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemPCIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemPCIMultiError) AllErrors() []error { return m }

// SystemPCIValidationError is the validation error returned by
// SystemPCI.Validate if the designated constraints aren't met.
type SystemPCIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemPCIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemPCIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemPCIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemPCIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemPCIValidationError) ErrorName() string { return "SystemPCIValidationError" }

// Error satisfies the builtin error interface
func (e SystemPCIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemPCI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemPCIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemPCIValidationError{}

// Validate checks the field values on Interfaces with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Interfaces) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Interfaces with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InterfacesMultiError, or
// nil if none found.
func (m *Interfaces) ValidateAll() error {
	return m.validate(true)
}

func (m *Interfaces) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClass()) > 128 {
		err := InterfacesValidationError{
			field:  "Class",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InterfacesMultiError(errors)
	}

	return nil
}

// InterfacesMultiError is an error wrapping multiple validation errors
// returned by Interfaces.ValidateAll() if the designated constraints aren't met.
type InterfacesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InterfacesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InterfacesMultiError) AllErrors() []error { return m }

// InterfacesValidationError is the validation error returned by
// Interfaces.Validate if the designated constraints aren't met.
type InterfacesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InterfacesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InterfacesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InterfacesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InterfacesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InterfacesValidationError) ErrorName() string { return "InterfacesValidationError" }

// Error satisfies the builtin error interface
func (e InterfacesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInterfaces.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InterfacesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InterfacesValidationError{}

// Validate checks the field values on SystemUSB with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemUSB) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemUSB with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemUSBMultiError, or nil
// if none found.
func (m *SystemUSB) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemUSB) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClass()) > 128 {
		err := SystemUSBValidationError{
			field:  "Class",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetIdvendor()) > 128 {
		err := SystemUSBValidationError{
			field:  "Idvendor",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetIdproduct()) > 128 {
		err := SystemUSBValidationError{
			field:  "Idproduct",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Bus

	// no validation rules for Addr

	if utf8.RuneCountInString(m.GetDescription()) > 128 {
		err := SystemUSBValidationError{
			field:  "Description",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSerial()) > 128 {
		err := SystemUSBValidationError{
			field:  "Serial",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetInterfaces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SystemUSBValidationError{
						field:  fmt.Sprintf("Interfaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SystemUSBValidationError{
						field:  fmt.Sprintf("Interfaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SystemUSBValidationError{
					field:  fmt.Sprintf("Interfaces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SystemUSBMultiError(errors)
	}

	return nil
}

// SystemUSBMultiError is an error wrapping multiple validation errors returned
// by SystemUSB.ValidateAll() if the designated constraints aren't met.
type SystemUSBMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemUSBMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemUSBMultiError) AllErrors() []error { return m }

// SystemUSBValidationError is the validation error returned by
// SystemUSB.Validate if the designated constraints aren't met.
type SystemUSBValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemUSBValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemUSBValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemUSBValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemUSBValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemUSBValidationError) ErrorName() string { return "SystemUSBValidationError" }

// Error satisfies the builtin error interface
func (e SystemUSBValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemUSB.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemUSBValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemUSBValidationError{}

// Validate checks the field values on BmInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BmInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BmInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BmInfoMultiError, or nil if none found.
func (m *BmInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BmInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BmType

	if all {
		switch v := interface{}(m.GetBmcInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BmInfoValidationError{
					field:  "BmcInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BmInfoValidationError{
					field:  "BmcInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBmcInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BmInfoValidationError{
				field:  "BmcInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BmInfoMultiError(errors)
	}

	return nil
}

// BmInfoMultiError is an error wrapping multiple validation errors returned by
// BmInfo.ValidateAll() if the designated constraints aren't met.
type BmInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BmInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BmInfoMultiError) AllErrors() []error { return m }

// BmInfoValidationError is the validation error returned by BmInfo.Validate if
// the designated constraints aren't met.
type BmInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BmInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BmInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BmInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BmInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BmInfoValidationError) ErrorName() string { return "BmInfoValidationError" }

// Error satisfies the builtin error interface
func (e BmInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBmInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BmInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BmInfoValidationError{}

// Validate checks the field values on BmcInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BmcInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BmcInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BmcInfoMultiError, or nil if none found.
func (m *BmcInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BmcInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBmIp()) > 128 {
		err := BmcInfoValidationError{
			field:  "BmIp",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBmUsername()) > 128 {
		err := BmcInfoValidationError{
			field:  "BmUsername",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBmPassword()) > 128 {
		err := BmcInfoValidationError{
			field:  "BmPassword",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BmcInfoMultiError(errors)
	}

	return nil
}

// BmcInfoMultiError is an error wrapping multiple validation errors returned
// by BmcInfo.ValidateAll() if the designated constraints aren't met.
type BmcInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BmcInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BmcInfoMultiError) AllErrors() []error { return m }

// BmcInfoValidationError is the validation error returned by BmcInfo.Validate
// if the designated constraints aren't met.
type BmcInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BmcInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BmcInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BmcInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BmcInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BmcInfoValidationError) ErrorName() string { return "BmcInfoValidationError" }

// Error satisfies the builtin error interface
func (e BmcInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBmcInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BmcInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BmcInfoValidationError{}

// Validate checks the field values on UpdateHostStatusByHostGuidRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateHostStatusByHostGuidRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateHostStatusByHostGuidRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateHostStatusByHostGuidRequestMultiError, or nil if none found.
func (m *UpdateHostStatusByHostGuidRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateHostStatusByHostGuidRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostGuid()) < 1 {
		err := UpdateHostStatusByHostGuidRequestValidationError{
			field:  "HostGuid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetHostGuid()) > 36 {
		err := UpdateHostStatusByHostGuidRequestValidationError{
			field:  "HostGuid",
			reason: "value length must be at most 36 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetHostGuid()); err != nil {
		err = UpdateHostStatusByHostGuidRequestValidationError{
			field:  "HostGuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetHostStatus() == nil {
		err := UpdateHostStatusByHostGuidRequestValidationError{
			field:  "HostStatus",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetHostStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateHostStatusByHostGuidRequestValidationError{
					field:  "HostStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateHostStatusByHostGuidRequestValidationError{
					field:  "HostStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHostStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateHostStatusByHostGuidRequestValidationError{
				field:  "HostStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateHostStatusByHostGuidRequestMultiError(errors)
	}

	return nil
}

func (m *UpdateHostStatusByHostGuidRequest) _validateUuid(uuid string) error {
	if matched := _hostmgr_southbound_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UpdateHostStatusByHostGuidRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateHostStatusByHostGuidRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateHostStatusByHostGuidRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateHostStatusByHostGuidRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateHostStatusByHostGuidRequestMultiError) AllErrors() []error { return m }

// UpdateHostStatusByHostGuidRequestValidationError is the validation error
// returned by UpdateHostStatusByHostGuidRequest.Validate if the designated
// constraints aren't met.
type UpdateHostStatusByHostGuidRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateHostStatusByHostGuidRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateHostStatusByHostGuidRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateHostStatusByHostGuidRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateHostStatusByHostGuidRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateHostStatusByHostGuidRequestValidationError) ErrorName() string {
	return "UpdateHostStatusByHostGuidRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateHostStatusByHostGuidRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateHostStatusByHostGuidRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateHostStatusByHostGuidRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateHostStatusByHostGuidRequestValidationError{}

// Validate checks the field values on UpdateHostSystemInfoByGUIDRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateHostSystemInfoByGUIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateHostSystemInfoByGUIDRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateHostSystemInfoByGUIDRequestMultiError, or nil if none found.
func (m *UpdateHostSystemInfoByGUIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateHostSystemInfoByGUIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostGuid()) < 1 {
		err := UpdateHostSystemInfoByGUIDRequestValidationError{
			field:  "HostGuid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetHostGuid()) > 36 {
		err := UpdateHostSystemInfoByGUIDRequestValidationError{
			field:  "HostGuid",
			reason: "value length must be at most 36 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetHostGuid()); err != nil {
		err = UpdateHostSystemInfoByGUIDRequestValidationError{
			field:  "HostGuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSystemInfo() == nil {
		err := UpdateHostSystemInfoByGUIDRequestValidationError{
			field:  "SystemInfo",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSystemInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateHostSystemInfoByGUIDRequestValidationError{
					field:  "SystemInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateHostSystemInfoByGUIDRequestValidationError{
					field:  "SystemInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSystemInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateHostSystemInfoByGUIDRequestValidationError{
				field:  "SystemInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateHostSystemInfoByGUIDRequestMultiError(errors)
	}

	return nil
}

func (m *UpdateHostSystemInfoByGUIDRequest) _validateUuid(uuid string) error {
	if matched := _hostmgr_southbound_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UpdateHostSystemInfoByGUIDRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateHostSystemInfoByGUIDRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateHostSystemInfoByGUIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateHostSystemInfoByGUIDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateHostSystemInfoByGUIDRequestMultiError) AllErrors() []error { return m }

// UpdateHostSystemInfoByGUIDRequestValidationError is the validation error
// returned by UpdateHostSystemInfoByGUIDRequest.Validate if the designated
// constraints aren't met.
type UpdateHostSystemInfoByGUIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateHostSystemInfoByGUIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateHostSystemInfoByGUIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateHostSystemInfoByGUIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateHostSystemInfoByGUIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateHostSystemInfoByGUIDRequestValidationError) ErrorName() string {
	return "UpdateHostSystemInfoByGUIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateHostSystemInfoByGUIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateHostSystemInfoByGUIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateHostSystemInfoByGUIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateHostSystemInfoByGUIDRequestValidationError{}

// Validate checks the field values on UpdateHostSystemInfoByGUIDResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateHostSystemInfoByGUIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateHostSystemInfoByGUIDResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateHostSystemInfoByGUIDResponseMultiError, or nil if none found.
func (m *UpdateHostSystemInfoByGUIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateHostSystemInfoByGUIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateHostSystemInfoByGUIDResponseMultiError(errors)
	}

	return nil
}

// UpdateHostSystemInfoByGUIDResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateHostSystemInfoByGUIDResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateHostSystemInfoByGUIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateHostSystemInfoByGUIDResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateHostSystemInfoByGUIDResponseMultiError) AllErrors() []error { return m }

// UpdateHostSystemInfoByGUIDResponseValidationError is the validation error
// returned by UpdateHostSystemInfoByGUIDResponse.Validate if the designated
// constraints aren't met.
type UpdateHostSystemInfoByGUIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateHostSystemInfoByGUIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateHostSystemInfoByGUIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateHostSystemInfoByGUIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateHostSystemInfoByGUIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateHostSystemInfoByGUIDResponseValidationError) ErrorName() string {
	return "UpdateHostSystemInfoByGUIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateHostSystemInfoByGUIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateHostSystemInfoByGUIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateHostSystemInfoByGUIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateHostSystemInfoByGUIDResponseValidationError{}

// Validate checks the field values on
// UpdateInstanceStateStatusByHostGUIDRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateInstanceStateStatusByHostGUIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateInstanceStateStatusByHostGUIDRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UpdateInstanceStateStatusByHostGUIDRequestMultiError, or nil if none found.
func (m *UpdateInstanceStateStatusByHostGUIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateInstanceStateStatusByHostGUIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetHostGuid()) > 36 {
		err := UpdateInstanceStateStatusByHostGUIDRequestValidationError{
			field:  "HostGuid",
			reason: "value length must be at most 36 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetHostGuid()); err != nil {
		err = UpdateInstanceStateStatusByHostGUIDRequestValidationError{
			field:  "HostGuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for InstanceStatus

	// no validation rules for InstanceState

	// no validation rules for ProviderStatusDetail

	if len(errors) > 0 {
		return UpdateInstanceStateStatusByHostGUIDRequestMultiError(errors)
	}

	return nil
}

func (m *UpdateInstanceStateStatusByHostGUIDRequest) _validateUuid(uuid string) error {
	if matched := _hostmgr_southbound_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UpdateInstanceStateStatusByHostGUIDRequestMultiError is an error wrapping
// multiple validation errors returned by
// UpdateInstanceStateStatusByHostGUIDRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateInstanceStateStatusByHostGUIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateInstanceStateStatusByHostGUIDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateInstanceStateStatusByHostGUIDRequestMultiError) AllErrors() []error { return m }

// UpdateInstanceStateStatusByHostGUIDRequestValidationError is the validation
// error returned by UpdateInstanceStateStatusByHostGUIDRequest.Validate if
// the designated constraints aren't met.
type UpdateInstanceStateStatusByHostGUIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateInstanceStateStatusByHostGUIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateInstanceStateStatusByHostGUIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateInstanceStateStatusByHostGUIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateInstanceStateStatusByHostGUIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateInstanceStateStatusByHostGUIDRequestValidationError) ErrorName() string {
	return "UpdateInstanceStateStatusByHostGUIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateInstanceStateStatusByHostGUIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateInstanceStateStatusByHostGUIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateInstanceStateStatusByHostGUIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateInstanceStateStatusByHostGUIDRequestValidationError{}

// Validate checks the field values on
// UpdateInstanceStateStatusByHostGUIDResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateInstanceStateStatusByHostGUIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateInstanceStateStatusByHostGUIDResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UpdateInstanceStateStatusByHostGUIDResponseMultiError, or nil if none found.
func (m *UpdateInstanceStateStatusByHostGUIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateInstanceStateStatusByHostGUIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateInstanceStateStatusByHostGUIDResponseMultiError(errors)
	}

	return nil
}

// UpdateInstanceStateStatusByHostGUIDResponseMultiError is an error wrapping
// multiple validation errors returned by
// UpdateInstanceStateStatusByHostGUIDResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateInstanceStateStatusByHostGUIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateInstanceStateStatusByHostGUIDResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateInstanceStateStatusByHostGUIDResponseMultiError) AllErrors() []error { return m }

// UpdateInstanceStateStatusByHostGUIDResponseValidationError is the validation
// error returned by UpdateInstanceStateStatusByHostGUIDResponse.Validate if
// the designated constraints aren't met.
type UpdateInstanceStateStatusByHostGUIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateInstanceStateStatusByHostGUIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateInstanceStateStatusByHostGUIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateInstanceStateStatusByHostGUIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateInstanceStateStatusByHostGUIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateInstanceStateStatusByHostGUIDResponseValidationError) ErrorName() string {
	return "UpdateInstanceStateStatusByHostGUIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateInstanceStateStatusByHostGUIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateInstanceStateStatusByHostGUIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateInstanceStateStatusByHostGUIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateInstanceStateStatusByHostGUIDResponseValidationError{}
